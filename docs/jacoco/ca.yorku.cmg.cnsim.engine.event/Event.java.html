<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Event.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CNSim Engine</a> &gt; <a href="index.source.html" class="el_package">ca.yorku.cmg.cnsim.engine.event</a> &gt; <span class="el_source">Event.java</span></div><h1>Event.java</h1><pre class="source lang-java linenums">package ca.yorku.cmg.cnsim.engine.event;

import ca.yorku.cmg.cnsim.engine.Simulation;
import ca.yorku.cmg.cnsim.engine.config.Config;
import ca.yorku.cmg.cnsim.engine.node.IMiner;
import ca.yorku.cmg.cnsim.engine.node.INode;
import ca.yorku.cmg.cnsim.engine.transaction.ITxContainer;
import ca.yorku.cmg.cnsim.engine.transaction.Transaction;

/**
 * Represents a single discrete occurrence within the event-driven simulation.
 * &lt;p&gt;
 * An {@code Event} encapsulates the notion of something happening at a particular
 * simulation time. Subclasses specialize this class to define concrete simulation
 * actions (for example, container arrivals, transaction propagation, etc.).
 * &lt;/p&gt;
 *
 * &lt;p&gt;Each event maintains a unique identifier, a simulation time, and an optional
 * flag indicating whether it should be ignored (useful for disregarding future events).&lt;/p&gt;
 *
 * @author 
 *     Sotirios Liaskos for the Conceptual Modeling Group @ York University
 */
<span class="fc" id="L24">public class Event {</span>
	
	/** A global counter for assigning unique event IDs. */
<span class="fc" id="L27">	public static long currID = 1;</span>

	/** The ID of the current event object. */
<span class="fc" id="L30">	public long evtID = 1;</span>
	
	/** If true, the event will be ignored when processed. Useful for disregarding future events. */
<span class="fc" id="L33">	protected boolean ignore = false;</span>
	
	/** The simulation time at which the event occurs. */
    private long time;

    
	// -----------------------------------------------------------------
    // ID MANAGEMENT
    // -----------------------------------------------------------------
    
    
    /**
     * Retrieves the next unique event identifier.
     *
     * @return The next available event ID.
     */
	public static long getNextEventID() {
<span class="fc" id="L50">		return(currID++);</span>
	}
	

    /**
     * Returns the unique identifier of this event instance.
     * IDs are assigned at the time the event is processed.
     *
     * @return The event ID.
     */
	public long getEvtID() {
<span class="fc" id="L61">		return evtID;</span>
	}
	
	
	// -----------------------------------------------------------------
	// SETTERS AND GETTERS
	// -----------------------------------------------------------------
	
    /**
     * Sets the time of occurrence for this event.
     *
     * @param time The simulation time (must be non-negative).
     * @throws ArithmeticException if {@code time &lt; 0}.
     */
    public void setTime(long time) {
<span class="pc bpc" id="L76" title="1 of 2 branches missed.">    	if(time &lt; 0)</span>
<span class="nc" id="L77">    		throw new ArithmeticException(&quot;Time &lt; 0&quot;);</span>
<span class="fc" id="L78">        this.time = time;</span>
<span class="fc" id="L79">    }</span>

    /**
     * Returns the simulation time at which this event occurs.
     *
     * @return The event's simulation time.
     */
    public long getTime() {
<span class="fc" id="L87">        return time;</span>
    }
    
    
	// -----------------------------------------------------------------
	// EVENT IGNORING
	// -----------------------------------------------------------------
    
    /**
     * Indicates whether this event should be ignored by the simulator.
     * Useful for canceling future events or suppressing redundant actions.
     *
     * @return {@code true} if the event should be ignored; {@code false} otherwise.
     */
    public boolean ignoreEvt() {
<span class="nc" id="L102">    	return ignore;</span>
    }
    
    
    /**
     * Sets whether this event should be ignored.
     *
     * @param ignoreEvt {@code true} to ignore the event, {@code false} otherwise.
     */
    public void ignoreEvt(boolean ignoreEvt) {
<span class="nc" id="L112">    	ignore = ignoreEvt;</span>
<span class="nc" id="L113">    }</span>
    
    
    
    /**
     * Executes the event in the context of a simulation.
     * &lt;p&gt;
     * This base implementation:
     * &lt;ul&gt;
     *   &lt;li&gt;Assigns a unique event ID.&lt;/li&gt;
     *   &lt;li&gt;Triggers periodic reporting on all nodes based on the
     *       configured reporting window (see {@linkplain Config}).&lt;/li&gt;
     *   &lt;li&gt;Triggers a time advancement report on each {@linkplain IMiner}.&lt;/li&gt;
     * &lt;/ul&gt;
     * Subclasses typically override this method to implement specific behaviors. Howver, Subclasses must call {@code super.happen(sim)} to allow the base functionality to execute.
     * TODO: introduce template method pattern to enforce calling super.happen(sim)
     * @param sim The active {@linkplain Simulation} instance.
     */
    public void happen(Simulation sim){
<span class="fc" id="L132">    	evtID = getNextEventID();</span>
 
    	// Every little while ask node if it wants to print any period reports.
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">    	if ((currID % Config.getPropertyLong(&quot;reporter.reportingWindow&quot;)) == 0) {</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">    		for (INode n : sim.getNodeSet().getNodes()) {</span>
<span class="nc" id="L137">    			n.periodicReport();</span>
<span class="nc" id="L138">    		}</span>
    	}

    	// Ask node if it wants to print Node report.
<span class="fc bfc" id="L142" title="All 2 branches covered.">		for (INode n : sim.getNodeSet().getNodes()) {</span>
<span class="fc" id="L143">			n.timeAdvancementReport();</span>
<span class="fc" id="L144">		}</span>
    	
<span class="fc" id="L146">    }</span>
   
	// -----------------------------------------------------------------
	// DEBUGGING AND PRINTING
	// -----------------------------------------------------------------
    
    
    /**
     * Prints a debug message describing the event and its associated transaction.
     * This is intended for development and tracing only.
	 * TODO: remove the parameters and make it specific on the event data.
     *
     * @param msg   A message prefix to display.
     * @param tx    The relevant {@linkplain Transaction} instance.
     * @param n     The relevant {@linkplain IMiner} instance.
     * @param tim   The simulation time.
     * @param delay The delay (in milliseconds) before continuing execution.
     */
	public void debugPrint(String msg, Transaction tx, INode n, long tim, long delay) {
<span class="nc" id="L165">		System.out.println(msg + tx.getID() + &quot; node &quot; + n.getID() + &quot; time &quot; + tim);</span>
		try {
<span class="nc" id="L167">			Thread.sleep(delay);</span>
<span class="nc" id="L168">		} catch (InterruptedException e) {e.printStackTrace();}</span>
<span class="nc" id="L169">	}</span>

	
    /**
     * Prints a debug message describing the event and its associated transaction container.
     * This is intended for development and tracing only.
     *
     * @param msg   A message prefix to display.
     * @param txc   The relevant {@linkplain ITxContainer} instance.
     * @param n     The relevant {@linkplain IMiner} instance.
     * @param tim   The simulation time.
     * @param delay The delay (in milliseconds) before continuing execution.
     */
	public void debugPrint(String msg, ITxContainer txc, INode n, long tim, long delay) {
<span class="nc" id="L183">		System.out.println(msg + txc.printIDs(&quot;,&quot;) + &quot; node &quot; + n.getID() + &quot; time &quot; + tim);</span>
		try {
<span class="nc" id="L185">			Thread.sleep(500);</span>
<span class="nc" id="L186">		} catch (InterruptedException e) {e.printStackTrace();}</span>
<span class="nc" id="L187">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>