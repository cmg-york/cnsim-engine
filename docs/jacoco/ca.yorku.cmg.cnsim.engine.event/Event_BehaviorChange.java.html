<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Event_BehaviorChange.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CNSim Engine</a> &gt; <a href="index.source.html" class="el_package">ca.yorku.cmg.cnsim.engine.event</a> &gt; <span class="el_source">Event_BehaviorChange.java</span></div><h1>Event_BehaviorChange.java</h1><pre class="source lang-java linenums">package ca.yorku.cmg.cnsim.engine.event;

import ca.yorku.cmg.cnsim.engine.Simulation;
import ca.yorku.cmg.cnsim.engine.node.INode;
import ca.yorku.cmg.cnsim.engine.reporter.Reporter;

/**
 * Represents an event that changes the behavior of a node in the simulation.
 * &lt;p&gt;
 * When this event occurs, the associated node's behavior is updated to the
 * new specified behavior type. This allows for dynamic changes in node behavior
 * during the simulation, such as switching from honest to malicious behavior,
 * or implementing other behavioral transitions.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For nodes that support behavior strategies (such as BitcoinNode), this event
 * will attempt to instantiate the appropriate behavior strategy based on the
 * behavior name. Currently supported behaviors include &quot;Honest&quot; and &quot;Malicious&quot;
 * for Bitcoin nodes.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The event can be scheduled at any simulation time to change a node's behavior
 * at that point in the simulation timeline.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Custom behavior strategies can be registered using the {@link #registerBehaviorStrategy(String, String, String)}
 * method. This allows extending the behavior system without modifying this class.
 * &lt;/p&gt;
 *
 * @author Amirreza Radjou for the Conceptual Modeling Group @ York University
 * @see INode#setBehavior(String)
 * @see INode#getBehavior()
 * @see Reporter
 */
public class Event_BehaviorChange extends Event {

	/**
	 * Registry for behavior strategy mappings.
	 * Maps behavior names (case-insensitive) to their fully qualified class names.
	 */
<span class="fc" id="L41">	private static final java.util.Map&lt;String, String&gt; behaviorStrategyRegistry = new java.util.HashMap&lt;&gt;();</span>

	// Initialize default behavior strategies
	static {
<span class="fc" id="L45">		registerBehaviorStrategy(&quot;Honest&quot;, &quot;ca.yorku.cmg.cnsim.bitcoin.node&quot;, &quot;HonestNodeBehavior&quot;);</span>
<span class="fc" id="L46">		registerBehaviorStrategy(&quot;Malicious&quot;, &quot;ca.yorku.cmg.cnsim.bitcoin.node&quot;, &quot;MaliciousNodeBehavior&quot;);</span>
<span class="fc" id="L47">	}</span>

	/**
	 * Registers a behavior strategy class for a given behavior name.
	 * This allows extending the behavior system with custom strategies.
	 *
	 * @param behaviorName the behavior name (e.g., &quot;Selfish&quot;, &quot;Custom&quot;)
	 * @param packageName the package containing the strategy class
	 * @param className the simple class name of the strategy
	 */
	public static void registerBehaviorStrategy(String behaviorName, String packageName, String className) {
<span class="pc bpc" id="L58" title="3 of 6 branches missed.">		if (behaviorName != null &amp;&amp; packageName != null &amp;&amp; className != null) {</span>
<span class="fc" id="L59">			behaviorStrategyRegistry.put(behaviorName.toLowerCase(), packageName + &quot;.&quot; + className);</span>
		}
<span class="fc" id="L61">	}</span>

	/**
	 * Clears all registered behavior strategies.
	 * Useful for testing or resetting the registry.
	 */
	public static void clearBehaviorStrategyRegistry() {
<span class="nc" id="L68">		behaviorStrategyRegistry.clear();</span>
<span class="nc" id="L69">	}</span>

	/** The node whose behavior will be changed. */
	private INode node;
	
	/** The new behavior type name (e.g., &quot;Honest&quot;, &quot;Malicious&quot;). */
	private String newBehavior;
	
	/** The previous behavior type (for reporting purposes). */
	private String oldBehavior;
	
	/** Optional target transaction ID for MaliciousNodeBehavior (can be -1 if not applicable). */
	private int targetTransactionID;

	/** Number of block confirmations required after target transaction before behavior change (0 = immediate). */
	private int requiredConfirmations;

	/** Height of the block containing the target transaction (-1 if not yet found). */
	private int targetTransactionBlockHeight;
	
	/**
	 * Constructs a new {@code Event_BehaviorChange}.
	 *
	 * @param node the node whose behavior will be changed
	 * @param newBehavior the new behavior type name (e.g., &quot;Honest&quot;, &quot;Malicious&quot;)
	 * @param time the simulation time at which the event occurs
	 * @throws IllegalArgumentException if newBehavior is null
	 */
	public Event_BehaviorChange(INode node, String newBehavior, long time) {
<span class="fc" id="L98">		this(node, newBehavior, time, -1, 0);</span>
<span class="fc" id="L99">	}</span>
	
	/**
	 * Constructs a new {@code Event_BehaviorChange} with an optional target transaction ID
	 * for MaliciousNodeBehavior.
	 *
	 * @param node the node whose behavior will be changed
	 * @param newBehavior the new behavior type name (e.g., &quot;Honest&quot;, &quot;Malicious&quot;)
	 * @param time the simulation time at which the event occurs
	 * @param targetTransactionID the target transaction ID for MaliciousNodeBehavior (ignored for other behaviors)
	 * @throws IllegalArgumentException if newBehavior is null
	 */
	public Event_BehaviorChange(INode node, String newBehavior, long time, int targetTransactionID) {
<span class="fc" id="L112">		this(node, newBehavior, time, targetTransactionID, 0);</span>
<span class="fc" id="L113">	}</span>

	/**
	 * Constructs a new {@code Event_BehaviorChange} with confirmation delay support.
	 * &lt;p&gt;
	 * This constructor allows the behavior change to be delayed until a specified number
	 * of blocks have been confirmed after the target transaction. This is useful for
	 * simulating scenarios where behavior changes based on transaction confirmation depth.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * If requiredConfirmations is 0, the behavior change happens immediately when the event occurs.
	 * If requiredConfirmations &gt; 0, the behavior change is delayed until that many blocks
	 * have been added to the blockchain after the block containing the target transaction.
	 * &lt;/p&gt;
	 *
	 * @param node the node whose behavior will be changed
	 * @param newBehavior the new behavior type name (e.g., &quot;Honest&quot;, &quot;Malicious&quot;)
	 * @param time the simulation time at which the event occurs
	 * @param targetTransactionID the target transaction ID for tracking confirmations (required if requiredConfirmations &gt; 0)
	 * @param requiredConfirmations the number of block confirmations to wait after target transaction (0 = immediate)
	 * @throws IllegalArgumentException if newBehavior is null or if {@code requiredConfirmations &gt; 0} but {@code targetTransactionID &lt; 0}
	 */
	public Event_BehaviorChange(INode node, String newBehavior, long time, int targetTransactionID, int requiredConfirmations) {
<span class="fc" id="L136">		super();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">		if (newBehavior == null) {</span>
<span class="fc" id="L138">			throw new IllegalArgumentException(&quot;Behavior name cannot be null&quot;);</span>
		}
<span class="fc bfc" id="L140" title="All 4 branches covered.">		if (requiredConfirmations &gt; 0 &amp;&amp; targetTransactionID &lt; 0) {</span>
<span class="fc" id="L141">			throw new IllegalArgumentException(&quot;Target transaction ID must be specified when using confirmation delay&quot;);</span>
		}
<span class="fc bfc" id="L143" title="All 2 branches covered.">		if (requiredConfirmations &lt; 0) {</span>
<span class="fc" id="L144">			throw new IllegalArgumentException(&quot;Required confirmations cannot be negative&quot;);</span>
		}
<span class="fc" id="L146">		this.node = node;</span>
<span class="fc" id="L147">		this.newBehavior = newBehavior;</span>
<span class="fc" id="L148">		this.oldBehavior = node.getBehavior();</span>
<span class="fc" id="L149">		this.targetTransactionID = targetTransactionID;</span>
<span class="fc" id="L150">		this.requiredConfirmations = requiredConfirmations;</span>
<span class="fc" id="L151">		this.targetTransactionBlockHeight = -1; // Will be determined when transaction is found</span>
<span class="fc" id="L152">		super.setTime(time);</span>
<span class="fc" id="L153">	}</span>
	
	/**
	 * Executes the event logic for changing a node's behavior.
	 * &lt;p&gt;
	 * This method updates the node's behavior to the new value. For BitcoinNode
	 * instances, it also attempts to set the appropriate behavior strategy.
	 * The event is logged to the reporter if event reporting is enabled.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * If confirmation delay is configured (requiredConfirmations &gt; 0) for a
	 * MaliciousNodeBehavior, the confirmation requirement is set on the behavior
	 * strategy itself. The behavior will internally wait for the specified number
	 * of block confirmations before starting the attack, using a counter-based
	 * approach rather than event rescheduling.
	 * &lt;/p&gt;
	 *
	 * @param sim the simulation instance in which the event occurs
	 * @see INode#setBehavior(String)
	 */
	@Override
	public void happen(Simulation sim) {
<span class="fc" id="L175">		super.happen(sim);</span>

		// Update the node's behavior string
<span class="fc" id="L178">		node.setBehavior(newBehavior);</span>
		
		// For BitcoinNode, also update the behavior strategy
		// We use reflection to avoid hard dependency on Bitcoin-specific classes
		try {
			// Check if the node has a setBehaviorStrategy method (BitcoinNode)
<span class="fc" id="L184">			java.lang.reflect.Method setBehaviorStrategyMethod =</span>
<span class="pc" id="L185">				node.getClass().getMethod(&quot;setBehaviorStrategy&quot;,</span>
<span class="nc" id="L186">					Class.forName(&quot;ca.yorku.cmg.cnsim.bitcoin.node.NodeBehaviorStrategy&quot;));</span>

			// Create the appropriate behavior strategy based on the behavior name
<span class="nc" id="L189">			Object strategy = createBehaviorStrategy(newBehavior, node);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">			if (strategy != null) {</span>
<span class="nc" id="L191">				setBehaviorStrategyMethod.invoke(node, strategy);</span>

				// If changing to MaliciousNodeBehavior, set target transaction and confirmation delay
<span class="nc bnc" id="L194" title="All 2 branches missed.">				if (newBehavior.equalsIgnoreCase(&quot;Malicious&quot;)) {</span>
					// Set target transaction ID if provided
<span class="nc bnc" id="L196" title="All 2 branches missed.">					if (targetTransactionID &gt;= 0) {</span>
						try {
<span class="nc" id="L198">							java.lang.reflect.Method setTargetTxMethod =</span>
<span class="nc" id="L199">								strategy.getClass().getMethod(&quot;setTargetTransaction&quot;, int.class);</span>
<span class="nc" id="L200">							setTargetTxMethod.invoke(strategy, targetTransactionID);</span>
<span class="nc" id="L201">						} catch (Exception e) {</span>
							// If setting target transaction fails, continue anyway
							// The behavior strategy has been set successfully
<span class="nc" id="L204">							System.err.println(&quot;Warning: Could not set target transaction for node &quot; +</span>
<span class="nc" id="L205">								node.getID() + &quot; behavior '&quot; + newBehavior + &quot;': &quot; + e.getMessage());</span>
<span class="nc" id="L206">						}</span>
					}

					// Set required confirmations before attack if specified
<span class="nc bnc" id="L210" title="All 2 branches missed.">					if (requiredConfirmations &gt; 0) {</span>
						try {
<span class="nc" id="L212">							java.lang.reflect.Method setConfirmationsMethod =</span>
<span class="nc" id="L213">								strategy.getClass().getMethod(&quot;setRequiredConfirmationsBeforeAttack&quot;, int.class);</span>
<span class="nc" id="L214">							setConfirmationsMethod.invoke(strategy, requiredConfirmations);</span>
<span class="nc" id="L215">						} catch (Exception e) {</span>
							// If setting confirmations fails, log warning
<span class="nc" id="L217">							System.err.println(&quot;Warning: Could not set required confirmations for node &quot; +</span>
<span class="nc" id="L218">								node.getID() + &quot; behavior '&quot; + newBehavior + &quot;': &quot; + e.getMessage());</span>
<span class="nc" id="L219">						}</span>
					}
				}
			} else {
				// Strategy creation returned null - either no strategy registered or instantiation failed
				// This is acceptable for behaviors that don't have strategy implementations
			}
<span class="nc" id="L226">		} catch (NoSuchMethodException e) {</span>
			// Node doesn't support behavior strategies (e.g., NodeStub for testing)
			// This is expected and acceptable - the behavior string has been set
<span class="fc" id="L229">		} catch (ClassNotFoundException e) {</span>
			// NodeBehaviorStrategy interface not found
			// This is expected for non-Bitcoin node types
<span class="nc" id="L232">		} catch (Exception e) {</span>
			// Unexpected error - log detailed warning but continue
			// The behavior string has been set successfully
<span class="nc" id="L235">			System.err.println(&quot;Warning: Unexpected error setting behavior strategy for node &quot; +</span>
<span class="nc" id="L236">				node.getID() + &quot; to '&quot; + newBehavior + &quot;': &quot; + e.getClass().getSimpleName() +</span>
<span class="nc" id="L237">				&quot; - &quot; + e.getMessage());</span>
<span class="pc" id="L238">		}</span>
		
<span class="fc" id="L240">		String msg = &quot;Node &quot; + &quot; switching to &quot; + this.newBehavior + &quot; from &quot; + this.oldBehavior + &quot; targeting &quot; + this.targetTransactionID + &quot; with &quot; + requiredConfirmations + &quot;required confirmations&quot;;</span>
		
		// Report the event if reporting is enabled
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">		if (Reporter.reportsEvents()) {</span>
<span class="nc" id="L244">			Reporter.addEvent(</span>
<span class="nc" id="L245">				sim.getSimID(),</span>
<span class="nc" id="L246">				getEvtID(),</span>
<span class="nc" id="L247">				getTime(),</span>
<span class="nc" id="L248">				System.currentTimeMillis() - Simulation.sysStartTime,</span>
<span class="nc" id="L249">				this.getClass().getSimpleName(),</span>
<span class="nc" id="L250">				node.getID(),</span>
				-1L, // No specific transaction or container involved
				msg
			);
		}
<span class="fc" id="L255">	}</span>
	
	/**
	 * Creates a behavior strategy instance based on the behavior name.
	 * This method uses reflection to instantiate the appropriate strategy
	 * class for Bitcoin nodes. The strategy class is looked up in the
	 * behavior strategy registry.
	 *
	 * @param behaviorName the name of the behavior (e.g., &quot;Honest&quot;, &quot;Malicious&quot;)
	 * @param node the node instance
	 * @return the behavior strategy instance, or null if creation fails
	 */
	private Object createBehaviorStrategy(String behaviorName, INode node) {
		try {
			// Look up the fully qualified class name in the registry
<span class="nc" id="L270">			String fullyQualifiedClassName = behaviorStrategyRegistry.get(behaviorName.toLowerCase());</span>

<span class="nc bnc" id="L272" title="All 2 branches missed.">			if (fullyQualifiedClassName == null) {</span>
				// No strategy registered for this behavior name
<span class="nc" id="L274">				return null;</span>
			}

			// Use reflection to instantiate the strategy
<span class="nc" id="L278">			Class&lt;?&gt; strategyClass = Class.forName(fullyQualifiedClassName);</span>
<span class="nc" id="L279">			java.lang.reflect.Constructor&lt;?&gt; constructor =</span>
<span class="nc" id="L280">				strategyClass.getConstructor(node.getClass());</span>
<span class="nc" id="L281">			return constructor.newInstance(node);</span>

<span class="nc" id="L283">		} catch (Exception e) {</span>
			// If we can't create the strategy, return null
			// The behavior string will still be set
<span class="nc" id="L286">			return null;</span>
		}
	}


	/**
	 * Returns the node whose behavior is being changed.
	 *
	 * @return the node instance
	 */
	public INode getNode() {
<span class="fc" id="L297">		return node;</span>
	}
	
	/**
	 * Returns the new behavior type that will be set.
	 *
	 * @return the new behavior type name
	 */
	public String getNewBehavior() {
<span class="fc" id="L306">		return newBehavior;</span>
	}
	
	/**
	 * Returns the previous behavior type (before the change).
	 *
	 * @return the old behavior type name
	 */
	public String getOldBehavior() {
<span class="fc" id="L315">		return oldBehavior;</span>
	}
	
	/**
	 * Returns the target transaction ID (if set for MaliciousNodeBehavior).
	 *
	 * @return the target transaction ID, or -1 if not set
	 */
	public int getTargetTransactionID() {
<span class="fc" id="L324">		return targetTransactionID;</span>
	}

	/**
	 * Returns the number of block confirmations required before behavior change.
	 *
	 * @return the required confirmations, or 0 for immediate behavior change
	 */
	public int getRequiredConfirmations() {
<span class="fc" id="L333">		return requiredConfirmations;</span>
	}

	/**
	 * Returns the height of the block containing the target transaction.
	 *
	 * @return the block height, or -1 if not yet found
	 */
	public int getTargetTransactionBlockHeight() {
<span class="fc" id="L342">		return targetTransactionBlockHeight;</span>
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>