<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StandardTransactionSampler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CNSim Engine</a> &gt; <a href="index.source.html" class="el_package">ca.yorku.cmg.cnsim.engine.sampling.standardsamplers</a> &gt; <span class="el_source">StandardTransactionSampler.java</span></div><h1>StandardTransactionSampler.java</h1><pre class="source lang-java linenums">package ca.yorku.cmg.cnsim.engine.sampling.standardsamplers;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.List;
import java.util.stream.IntStream;

import ca.yorku.cmg.cnsim.engine.Debug;
import ca.yorku.cmg.cnsim.engine.config.Config;
import ca.yorku.cmg.cnsim.engine.sampling.Sampler;
import ca.yorku.cmg.cnsim.engine.sampling.interfaces.AbstractTransactionSampler;
import ca.yorku.cmg.cnsim.engine.transaction.Transaction;


/**
 * A standard implementation of {@link AbstractTransactionSampler}.
 * &lt;p&gt;
 * This sampler provides transaction-level samples for simulation purposes, including:
 * &lt;ul&gt;
 *     &lt;li&gt;Transaction arrival intervals (Poisson distribution)&lt;/li&gt;
 *     &lt;li&gt;Transaction fee values (Normal distribution)&lt;/li&gt;
 *     &lt;li&gt;Transaction sizes (Normal distribution with lower bound)&lt;/li&gt;
 *     &lt;li&gt;Random integers for generic sampling (Uniform distribution)&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Supports optional seed updates to enable reproducible random sequences, controlled 
 * by {@code seedUpdateEnabled}, {@code seedSwitchTx}, and {@code simID}.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;Author: Sotirios Liaskos for the Conceptual Modeling Group @ York University&lt;/p&gt;
 */
public class StandardTransactionSampler extends AbstractTransactionSampler {
	    
	
    /** Simulation ID for reproducible seed updates */
    private int simID;

    /** Transaction ID at which to switch seed */
    private long seedSwitchTx;

    /** Initial seed value */
    private long initialSeed;

    /** Current seed in use */
    private long currentSeed;

    /** Flag to enable/disable seed updates */
<span class="fc" id="L48">    private boolean seedUpdateEnabled = false;</span>
    
    

    // -----------------------------------------------------------------
    // CONSTRUCTORS
    // -----------------------------------------------------------------

    
    /**
     * Constructs a StandardTransactionSampler with the specified {@linkplain Sampler}.
     * Loads configuration from {@linkplain Config}.
     *
     * @param s the Sampler instance to use for generating random samples
     */
<span class="fc" id="L63">    public StandardTransactionSampler(Sampler s) {</span>
<span class="fc" id="L64">    	this.sampler = s;</span>
<span class="fc" id="L65">    	LoadConfig();</span>
<span class="fc" id="L66">    }</span>
	    
    /**
     * Constructs a StandardTransactionSampler with the specified {@linkplain Sampler} 
     * and simulation ID.
     *
     * @param s the Sampler instance to use
     * @param simID the simulation ID for reproducible seed updates
     */
    public StandardTransactionSampler(Sampler s, int simID) {
<span class="fc" id="L76">    	this(s);</span>
<span class="fc" id="L77">    	this.simID = simID;</span>
<span class="fc" id="L78">    }</span>
    
    // -----------------------------------------------------------------
    // SEED MANAGEMENT
    // -----------------------------------------------------------------

    /**
     * Updates the current seed if seed update is enabled and the transaction ID
     * has passed the configured switch point.
     */
    public void updateSeed() {
<span class="fc bfc" id="L89" title="All 4 branches covered.">    	if ((seedUpdateEnabled) &amp;&amp; (seedSwitchTx &lt; Transaction.currID - 1)) {</span>
<span class="fc" id="L90">    		currentSeed = this.initialSeed + this.simID;</span>
<span class="fc" id="L91">    		super.random.setSeed(currentSeed);</span>
<span class="fc" id="L92">    		seedUpdateEnabled = false;</span>
    	}
<span class="fc" id="L94">    }</span>

    /**
	 * Returns the current seed in use.
	 * @return the current seed value
	 */
    public long getCurrentSeed() {
<span class="fc" id="L101">    	return this.currentSeed;</span>
    }
    
    
	@Override
	public long getSeedChangeTx() {
<span class="nc" id="L107">		return (this.seedSwitchTx);</span>
	}
    
	@Override
	public boolean seedUpdateEnabled() {
<span class="nc" id="L112">		return (this.seedUpdateEnabled);</span>
	}

	
	

	
	
	// -----------------------------------------------------------------
    // TRANSACTION SAMPLING
    // -----------------------------------------------------------------

    /**
     * Returns a sample of the interval until the next transaction arrives.
     * &lt;p&gt;
     * Uses a Poisson distribution with rate {@code txArrivalIntervalRate}.
     * Interval is returned in milliseconds.
     * &lt;/p&gt;
     *
     * @return a sampled transaction arrival interval in milliseconds
     * @throws Exception if sampling fails
     */
	@Override
	public float getNextTransactionArrivalInterval() throws Exception {
<span class="fc" id="L136">    	updateSeed();</span>
<span class="fc" id="L137">		return (float) sampler.getPoissonInterval(txArrivalIntervalRate,random)*1000;</span>
	}
	
    /**
     * Returns a sample of the transaction fee.
     * &lt;p&gt;
     * Uses a Normal (Gaussian) distribution with mean {@code txValueMean} 
     * and standard deviation {@code txValueSD}.
     * &lt;/p&gt;
     *
     * @return a sampled transaction fee value
     * @see AbstractTransactionSampler#getNextTransactionFeeValue()
     */
    @Override
    public float getNextTransactionFeeValue() {
<span class="nc" id="L152">        return(sampler.getGaussian(txValueMean, txValueSD, random));</span>
    }

    /**
     * Returns a sample of the transaction size.
     * &lt;p&gt;
     * Uses a Normal distribution with mean {@code txSizeMean} and standard deviation {@code txSizeSD}.
     * A minimum size of 10 is enforced. If a valid sample cannot be generated within 100 tries, 
     * the program exits with an error.
     * &lt;/p&gt;
     *
     * @return a sampled transaction size (long)
     * @throws RuntimeException 
     */
    @Override
    public long getNextTransactionSize()  {
    	long result; 
<span class="nc" id="L169">    	long minSize = 10;</span>
    	
<span class="nc" id="L171">    	int maxTries = 100;</span>
<span class="nc" id="L172">    	int tries = 0;</span>
    	
    	do {
<span class="nc" id="L175">    		result = (long) sampler.getGaussian(txSizeMean, txSizeSD, random);</span>
<span class="nc" id="L176">    		tries++;</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">    	} while ((result &lt; minSize) &amp;&amp; (tries &lt; maxTries));</span>
    	
<span class="nc bnc" id="L179" title="All 2 branches missed.">    	if (tries == maxTries) {</span>
<span class="nc" id="L180">    		Debug.e(&quot;StandardTransactionSampler: Failed to generate appropriate transaction size after &quot; + tries + &quot; tries. Please check workload.txSizeMean and workload.txSizeSD.&quot;);</span>
<span class="nc" id="L181">    		throw new RuntimeException(&quot;StandardTransactionSampler: Failed to generate appropriate transaction size after &quot; + tries + &quot; tries. Please check workload.txSizeMean and workload.txSizeSD.&quot;);</span>
    	}
<span class="nc" id="L183">        return(result);</span>
    }
    
    @Override
    //Decided at the Simulation level where there is access to the corresponding NodeSet 
	public int getArrivalNode() {
<span class="nc" id="L189">		return -1;</span>
	}
    
    /**
     * Returns a random integer between the given bounds (inclusive).
     * &lt;p&gt;
     * Uses a Uniform distribution.
     * &lt;/p&gt;
     *
     * @param min the minimum value (inclusive)
     * @param max the maximum value (inclusive)
     * @return a random integer in [min, max]
     * @see AbstractTransactionSampler#getRandom()
     */
    @Override
    public int getRandomNum(int min, int max) {
        //return(sampler.getTransactionSampler().getRandom().nextInt((max - min) + 1) + min);
<span class="nc" id="L206">    	return(random.nextInt((max - min) + 1) + min);</span>
    }

    
    /**
     * Pick a random match for a given ID with distance bias controlled by alpha.
     * 
     * @param id    Target ID (1 .. N)
     * @param N     Total number of IDs
     * @param dispersion Closeness parameter [0,1]:
     *              0 -&gt; almost always near 'id'
     *              1 -&gt; can pick anywhere in range (near edges possible)
     * @param likelihood The likelihood that the transaction has a conflict.
     * @return      Randomly chosen matching ID
     */
    public int getConflict(int id, int N, double dispersion, double likelihood) {
<span class="fc bfc" id="L222" title="All 4 branches covered.">        if (dispersion &lt; 0 || dispersion &gt; 1) {</span>
<span class="fc" id="L223">            throw new IllegalArgumentException(&quot;alpha must be in [0,1]&quot;);</span>
        }
<span class="fc bfc" id="L225" title="All 4 branches covered.">        if (id &lt; 1 || id &gt; N) {</span>
<span class="fc" id="L226">            throw new IllegalArgumentException(&quot;id must be in [1, N]&quot;);</span>
        }
<span class="fc bfc" id="L228" title="All 2 branches covered.">        if (N &lt;= 1) {</span>
<span class="fc" id="L229">            throw new IllegalArgumentException(&quot;Cannot pick a conflict when only one ID exists&quot;);</span>
        }
        
        
        // No conflict based on likelihood
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (random.nextDouble() &gt;= likelihood) {</span>
<span class="nc" id="L235">            return -1;</span>
        }
        
        // Compute the maximum possible forward distance
<span class="fc" id="L239">        int maxDistance = N - id;</span>
        
<span class="pc bpc" id="L241" title="1 of 2 branches missed.">        if (maxDistance == 0) {</span>
<span class="nc" id="L242">            return -1; // no forward conflict possible</span>
        }

        // Sample uniform random number
<span class="fc" id="L246">        double U = random.nextDouble(); // [0,1)</span>
        
        // Exponential distance biased by dispersion (alpha)
<span class="fc" id="L249">        int d = (int) Math.floor(-Math.log(U) * Math.pow(maxDistance, dispersion));</span>

        // Ensure we move at least 1 forward
<span class="fc bfc" id="L252" title="All 2 branches covered.">        if (d &lt; 1) d = 1;</span>

        // Candidate is always forward
<span class="fc" id="L255">        int candidate = id + d;</span>
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (candidate &gt; N) candidate = N; // clamp</span>

<span class="fc" id="L258">        return candidate;</span>
    }
    
    
    
    /**
     * Generate a random dependency for Transaction txID
     *
     * @param txID        Transaction for which dependencies are generated. An integer greater than 0.
     * @param mandatory  if {@code true}, at least one dependency will be created
     * @param dispersion  float [0..1], measures how far from txID the numbers are
     * @param countMean  expected number of dependencies (0..txID-1)
     * @param countSD    standard deviation for number of dependencies
     * @return a BitSet of dependencies, or null if no dependencies
     */
    public BitSet randomDependencies(int txID, boolean mandatory, float dispersion, int countMean, float countSD) {

<span class="fc" id="L275">    	int j = txID;</span>
    	
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (j &lt;= 1) return null;</span>

        // 1. Draw N from normal distribution
<span class="fc" id="L280">        int N = (int) Math.round(countMean + random.nextGaussian() * countSD);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        N = mandatory ? Math.max(1, N): Math.max(0, N); </span>
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (N == 0) return null;</span>

<span class="fc" id="L284">        int maxDep = j - 1;</span>
<span class="fc" id="L285">        N = Math.min(N, maxDep); // cannot pick more than j-1 numbers</span>

<span class="fc" id="L287">        BitSet deps = new BitSet(j);</span>

        // 2. Create list of all possible numbers &lt; j
<span class="fc" id="L290">        List&lt;Integer&gt; candidates = new ArrayList&lt;&gt;(IntStream.range(1, j).boxed().toList());</span>

        // 3. Assign a weight to each candidate based on left-tail normal bias
<span class="fc" id="L293">        List&lt;Double&gt; keys = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">        for (int num : candidates) {</span>
            // approximate left-tail normal: higher numbers less likely
<span class="fc" id="L296">            keys.add(Math.pow(random.nextDouble(), 1.0 / Math.max(dispersion, 0.0001)));</span>
<span class="fc" id="L297">        }</span>

        // 4. Sort candidates by keys descending â†’ biased selection
<span class="fc" id="L300">        candidates.sort((a, b) -&gt; Double.compare(keys.get(b - 1), keys.get(a - 1)));</span>

        // 5. Pick first N numbers
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for (int i = 0; i &lt; N; i++) {</span>
<span class="fc" id="L304">            deps.set(candidates.get(i));</span>
        }

<span class="fc" id="L307">        return deps;</span>
    }
    
    
    
    /**
     * Loads configuration values from {@linkplain Config} for transaction sampling.
     * Initializes seed update settings and current/initial seeds.
     */
    @Override
    public void LoadConfig() {
<span class="fc" id="L318">    	super.LoadConfig();</span>
<span class="pc bpc" id="L319" title="1 of 2 branches missed.">    	this.seedUpdateEnabled = (Config.hasProperty(&quot;workload.sampler.seed.updateSeed&quot;) ? Config.getPropertyBoolean(&quot;workload.sampler.seed.updateSeed&quot;) : false);</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">    	this.seedSwitchTx = (Config.hasProperty(&quot;workload.sampler.seed.updateTransaction&quot;) ? Config.getPropertyLong(&quot;workload.sampler.seed.updateTransaction&quot;) : 0);</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">    	this.currentSeed = (Config.hasProperty(&quot;workload.sampler.seed&quot;) ? Config.getPropertyLong(&quot;workload.sampler.seed&quot;) : 0);</span>
<span class="fc" id="L322">    	this.initialSeed = this.currentSeed;</span>
<span class="fc" id="L323">    }</span>

    
    
    // -----------------------------------------------------------------
    // TESING RELATED METHODS
    // -----------------------------------------------------------------

    
    
    /**
     * Sets seed-related configuration for testing purposes.
     *
     * @param initSeed initial seed value
     * @param seedUpdateEnabled whether seed updates are enabled
     * @param seedSwitchTx transaction ID at which seed should switch
     */
    public void nailConfig(long initSeed, boolean seedUpdateEnabled, long seedSwitchTx) {
<span class="fc" id="L341">    	this.seedUpdateEnabled = seedUpdateEnabled;</span>
<span class="fc" id="L342">    	this.seedSwitchTx = seedSwitchTx;</span>
<span class="fc" id="L343">    	this.currentSeed = initSeed;</span>
<span class="fc" id="L344">    	this.initialSeed = this.currentSeed;</span>
<span class="fc" id="L345">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>