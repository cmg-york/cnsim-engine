<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionWorkload.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">CNSim Engine</a> &gt; <a href="index.source.html" class="el_package">ca.yorku.cmg.cnsim.engine.transaction</a> &gt; <span class="el_source">TransactionWorkload.java</span></div><h1>TransactionWorkload.java</h1><pre class="source lang-java linenums">package ca.yorku.cmg.cnsim.engine.transaction;

import java.util.ArrayList;
import java.util.List;

import ca.yorku.cmg.cnsim.engine.sampling.Sampler;

/**
 * Represents a workload of transactions, which can be generated either from a file or using a sampler.
 * This class extends TransactionGroup and provides methods to add and manage transactions.
 * 
 * @author Sotirios Liaskos, Nahid Alimohammadi
 * @see TransactionGroup
 */
public class TransactionWorkload extends TransactionGroup {

    private Sampler sampler;
<span class="nc" id="L18">    private long timeEnd = 0;</span>

   
    /**
     * Constructs a TransactionWorkload with the given sampler.
     * @param sampler The sampler used to generate transaction attributes.
     */
<span class="nc" id="L25">    public TransactionWorkload(Sampler sampler) {</span>
<span class="nc" id="L26">        this.sampler = sampler;</span>

<span class="nc" id="L28">    }</span>
    
    /**
     * Adds a specified number of transactions from a given start time.
     * @param num The number of transactions to add.
     * @param startTime The start time of the first transaction.
     * @throws ArithmeticException If the start time or number of transactions is less than 0.
     * @throws Exception 
     */
    private void addTransactions(long num, long startTime) throws Exception{
<span class="nc bnc" id="L38" title="All 2 branches missed.">    	if(startTime &lt; 0)</span>
<span class="nc" id="L39">    		throw new ArithmeticException(&quot;startTime &lt; 0&quot;);</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">    	if(num &lt; 0)</span>
<span class="nc" id="L41">    		throw new ArithmeticException(&quot;num &lt; 0&quot;);</span>
<span class="nc" id="L42">        long currTime = startTime;</span>

<span class="nc bnc" id="L44" title="All 2 branches missed.">        for (long i = 1; i &lt;= num; i++){</span>
            try {
<span class="nc" id="L46">				currTime += (long) sampler.getTransactionSampler().getNextTransactionArrivalInterval();</span>
<span class="nc" id="L47">			} catch (Exception e) {</span>
<span class="nc" id="L48">				e.printStackTrace();</span>
<span class="nc" id="L49">			}</span>
<span class="nc" id="L50">            addTransaction(currTime);</span>
        }
<span class="nc" id="L52">        timeEnd = currTime;</span>
<span class="nc" id="L53">    }</span>

    
    
    /**
     * Appends a specified number of transactions after the last transaction in the workload.
     * @param num The number of transactions to append.
     * @throws ArithmeticException If the number of transactions is less than 0.
     * @throws Exception  
     */
    public void appendTransactions(long num) throws Exception {
<span class="nc bnc" id="L64" title="All 2 branches missed.">    	if(num &lt; 0)</span>
<span class="nc" id="L65">    		throw new ArithmeticException(&quot;num &lt; 0&quot;);</span>
<span class="nc" id="L66">        addTransactions(num, timeEnd);</span>
<span class="nc" id="L67">    }</span>
    
    /**
     * Adds a transaction with the given current time.
     * @param currTime The current time of the transaction.
     * @throws Exception 
     */
    public void addTransaction(long currTime) throws Exception{
        Transaction t;
        
<span class="nc" id="L77">        long trID = Transaction.getNextTxID();</span>
        
<span class="nc" id="L79">        t = new Transaction(trID,</span>
                currTime,
<span class="nc" id="L81">                sampler.getTransactionSampler().getNextTransactionFeeValue(),</span>
<span class="nc" id="L82">                sampler.getTransactionSampler().getNextTransactionSize(),</span>
<span class="nc" id="L83">                sampler.getTransactionSampler().getArrivalNode());</span>
        
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (trID == sampler.getTransactionSampler().getSeedChangeTx()) {</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        	if (sampler.getTransactionSampler().seedUpdateEnabled()) {</span>
<span class="nc" id="L87">            	t.makeSeedChanging();</span>
<span class="nc" id="L88">            	sampler.getTransactionSampler().updateSeed();</span>
        	}
        }
        
<span class="nc" id="L92">        addTransaction(t);</span>
<span class="nc" id="L93">    }</span>
    
	/**
	 * Picks a specified number of random transactions from the workload based on the given percentile value.
	 * @param transNo The number of transactions to pick.
	 * @param percentile The percentile value to determine the range for picking transactions. For example from 
	 * 100 transactions with indexes 1..100, percentile 0.25 will return samples from the first 25 transactions 
	 * (indexes 1..25)  
	 * @return An ArrayList of randomly picked transactions possibly with duplicates.
	 */
	public ArrayList&lt;Transaction&gt; pickRandomTransactions(int transNo,float percentile) {
<span class="nc" id="L104">		ArrayList&lt;Transaction&gt; rtx = new ArrayList&lt;Transaction&gt;();</span>
		
<span class="nc bnc" id="L106" title="All 2 branches missed.">		for (int i=1;i&lt;=transNo;i++) {</span>
<span class="nc" id="L107">			rtx.add(getTransaction(sampler.getTransactionSampler().getRandomNum(0, Math.round((getCount()-1)*percentile))));</span>
		}
<span class="nc" id="L109">		return rtx;</span>
	}

	/**
	 * Updates the given TxConflictRegistry with conflicts based on the specified dispersion and likelihood.
	 * @param reg The TxConflictRegistry to be updated.
	 * @param dispersion The dispersion parameter controlling the closeness of conflicts. In [0,1].
	 * @param likelihood The likelihood of a transaction having a conflict. In [0,1]
	 */
	public void updateConflicts(
			TxConflictRegistry reg, 
			double dispersion, double likelihood) {
		
		//System.err.print(&quot;I count: [&quot;);
<span class="nc bnc" id="L123" title="All 2 branches missed.">		for (Transaction tx : getAllTransactions()) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">			if (reg.getMatch((int) tx.getID()) == -2) {</span>
<span class="nc" id="L125">				int conflict = sampler.getTransactionSampler().getConflict(</span>
<span class="nc" id="L126">						(int) tx.getID(),</span>
<span class="nc" id="L127">						getAllTransactions().size(), </span>
						dispersion, likelihood);
				
<span class="nc bnc" id="L130" title="All 4 branches missed.">				if ((conflict == -1) || (reg.getMatch(conflict) != -2)) {</span>
<span class="nc" id="L131">					reg.noMatch((int) tx.getID());</span>
					//System.err.print(&quot;(&quot; + tx.getID() + &quot; &lt;-&gt; &quot; + -1 + &quot;), &quot;);
				} else {
<span class="nc bnc" id="L134" title="All 2 branches missed.">					if (conflict &lt;= tx.getID()) {</span>
<span class="nc" id="L135">						throw new IllegalStateException(&quot;Conflicting ID must be larger than current tx ID&quot;);</span>
					}
<span class="nc" id="L137">					reg.setMatch((int) tx.getID(), conflict);</span>
					//System.err.print(&quot;(&quot; + tx.getID() + &quot; &lt;-&gt; &quot; + conflict + &quot;), &quot;);
				}
			} else {
				//System.err.print(&quot;(&quot; + tx.getID() + &quot; &lt;-&gt; &quot; + reg.getMatch((int) tx.getID()) + &quot;), &quot;);
			}
			
<span class="nc" id="L144">		}</span>
		//System.err.println(&quot;]&quot;);
<span class="nc" id="L146">	}</span>

	
	public void updateDependencies(TxDependencyRegistry reg, boolean mandatory, float dispersion, int countMean, float countSD) {
		//System.err.print(&quot;I count: [&quot;);
<span class="nc bnc" id="L151" title="All 2 branches missed.">		for (Transaction tx : getAllTransactions()) {</span>
<span class="nc" id="L152">			reg.addDependencies((int) tx.getID(), </span>
<span class="nc" id="L153">					sampler.getTransactionSampler().randomDependencies((int) tx.getID(), mandatory, </span>
							dispersion, countMean, countSD));
<span class="nc" id="L155">		}</span>
<span class="nc" id="L156">	}</span>
	
	
	
    //TODO Why did not used get group directly
	public List&lt;Transaction&gt; getAllTransactions() {
<span class="nc" id="L162">    	return getTransactions();</span>
    }

	   
    
    /**
     * See {@linkplain TransactionGroup#TransactionGroup(String, boolean)} 
     * @param fileName The workload filename to be read.
     * @param hasHeader Whether the file has a header.
     * @throws Exception Generic IO exception.
     */
    public TransactionWorkload(String fileName, boolean hasHeader) throws Exception {
<span class="nc" id="L174">    	super(fileName, hasHeader);</span>
<span class="nc" id="L175">    }</span>



}
    
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>